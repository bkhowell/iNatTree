---
title: "iNat"
output: html_notebook
---

Install packages if necessary

```{r}
library(devtools)
install_github("https://github.com/ropensci/rinat")
install_github("https://github.com/phylotastic/datelife")
install.packages("rotl")
install.packages("jpeg")
install.packages("plotly")
```

Load packages

```{r}
library(rinat)
library(datelife)
library(dplyr)
library(jpeg)
library(treeplyr)
library(ape)
library(httr)
library(curl)
library(jsonlite)
library(rotl)
```

# Functions 

```{r}

getTaxonomyTable <- function(taxalist, rank=r){
  simpleCap <- function(x) {
    s <- strsplit(x, "_")[[1]]
    paste(toupper(substring(s, 1,1)), substring(s, 2),
          sep="", collapse=" ")
  }
  getOttIds <- function(taxalist, ncores=1, context=NULL){
    scipen <- options()$scipen
    digits <- options()$digits
    options("scipen"=100, "digits"=4)
    .taxalist <- gsub("_", " ", taxalist)
    .taxalist <- gsub(" sp$", "", .taxalist)
    tax <- parallel::mclapply(1:length(taxalist),  function(i) try(rotl::tnrs_match_names(.taxalist[i], do_approximate_matching =FALSE, context_name = context)), mc.cores=ncores)
    failed <- which(sapply(tax,function(x) class(x)[1]=="try-error"))
    if(length(failed)>0){
      tax[failed] <- parallel::mclapply(failed,  function(i) try(rotl::tnrs_match_names(.taxalist[i], do_approximate_matching =TRUE, context_name = context)), mc.cores=ncores)
    }
    stillfailed <- which(sapply(tax,function(x) if(class(x)[1]=="try-error"){TRUE} else {is.na(x$ott_id)} ))
    if(length(stillfailed>0)){
      tax[stillfailed] <- lapply(stillfailed, function(x) data.frame(search_string=.taxalist[x], unique_name=.taxalist[x], approximate_match=NA, ott_id=NA, is_synonym=NA, flags=NA, number_matches=0))
    }
    tax <- do.call(rbind, tax)
    genspec <- unname(sapply(tax[,2], function(x) paste(strsplit(x, split=" ")[[1]][1:2],collapse=" ")))
    genspec <- gsub(" (genus", " sp.", genspec, fixed=TRUE)
    genspec <- gsub(" NA", " sp.", genspec, fixed=TRUE)
    if(sum(duplicated(genspec))>0){
      cat("Dropping duplicated taxa: ", paste(taxalist[duplicated(genspec)], collapse=", "), "\n")
    }
    if(sum(is.na(tax$ott_id))>0){
      cat("No ott ids found for taxa: ", paste(taxalist[is.na(tax$ott_id)], collapse=", "), "\n")
    }
    tax_unique <- tax[!(duplicated(genspec) | is.na(tax$ott_id)),]
    tax_unique$ottids <- as.character(tax_unique$ott_id)
    options("scipen"=scipen, "digits"=digits)
    tax_unique[,1] <- gsub(" ", "_", tax_unique[,1])
    tax_unique[,1] <- sapply(tax_unique[,1], function(x) simpleCap(x))
    return(tax_unique)
  }
  
  otts <- getOttIds(taxalist)
  taxonomies <- lapply(otts$ott_id, function(x) rotl::taxonomy_taxon_info(x, include_lineage = TRUE))
  taxonomies <- lapply(taxonomies, function(x) do.call(rbind, x[[1]]$lineage))
  taxonomies <- lapply(taxonomies, function(x) x[x[,"rank"]==rank,])
  taxtable <- do.call(rbind, taxonomies)
  return(taxtable)
}

```

# getting tree for users, using all dates

```{r}
username <- c("pipsissewa", "josefuyeda", "nicbone", "leightonreid")
```

```{r}
obs_list <- list()
for(i in 1:length(username)) {
  temp_obs <- rinat::get_inat_obs_user(username[[i]])
  temp_obs <- filter(temp_obs, grepl("VA", temp_obs$place_guess))
  temp_obs <- filter(temp_obs, iconic_taxon_name == "Fungi" | iconic_taxon_name == "Plantae")
  obs_list[[i]] <- temp_obs
}

obs <- bind_rows(obs_list, .id = "user")
obs$genspec <- gsub(" ", "_", as.character(obs$scientific_name))
obs <- as.data.frame(obs)
obs <- filter(obs, grepl("_", obs$genspec))

#species<-as.data.frame(obs$genspec)
ottTable <- tnrs_match_names(obs$genspec)
length(ottTable$unique_name)

## have to remove flagged ottids or tol_induced_subtree throws error, may cause issues with other data if 
## problematic ids aren't flagged
## test with other users
ottids <-ottTable[ottTable$flags == "", ]
ottids <- na.omit(ottids)

## need to use format=id so that nodes are easy to pull dates for below
synth_tree <- rotl::tol_induced_subtree(ott_ids=ottids$ott_id, label_format = "id")
nodes <- synth_tree$node.label

res <- list()
for(i in 1:length(nodes)){
  body <- list(node=nodes[i])
  path <- "dates/synth_node_age"
  url <- "https://dates.opentreeoflife.org"
  node_id <- gsub(" ", "_", nodes[i])
  otl_v <- "v4"
  body_json <- ifelse(length(body), jsonlite::toJSON(body), "")
  httr::set_config(config(ssl_verifypeer=0L))
  req <- httr::GET(url, path = paste(otl_v, path, node_id, sep = "/"))
  res[[i]] <- httr::content(req)
}


#####
### native status query
## only query if native (returns if species establishment_means = native or endemic), if not native assumed 
## introduced (i.e. introduced, managed, naturalized, or invasive)
## could be problematic for species not in VA (will be returned introduced even if they are native where the obs 
## occurred)

native_status<-matrix(data=NA, nrow = length(ottids$unique_name), ncol = 3)
colnames(native_status)<-c("scientific_name", "native", "id")

for (t in 1:length(ottids$unique_name)) {
  
  native_status[t,1]<-ottids$unique_name[t]
  native_status[t,3]<-gsub(" ", "", paste("ott",ottids$ott_id[t]))
  url <- "https://inaturalist.org"
  places <- "/places.json?"
  taxon <- gsub(" ", "", paste("taxon=",gsub(" ", "+", ottids$unique_name[t])))
  place_type <- "place_type=state"
  state <- "q=Virginia"
  em <- "establishment_means=native"
  stat<-httr::GET(url, path=paste(places, paste(taxon, place_type, state, em, sep = "&"), sep = ""))
  stat<-httr::content(stat)
  
  if (length(stat)==0) {
    
    native_status[t,2]<- 0
    
  } else {
    
    native_status[t,2]<-1
  }
}


native_status[,2] <- as.numeric(native_status[,2])

o <- merge(obs, native_status, by = "scientific_name")

#####


## getting node ages from res list
## had to add if is.null ages[[i]] <- NA because it was causing issues with real iNat data
## number of things in ages list wasn't matching total number of nodes without that line

ages <- list()

for(i in 1:length(res)) {
  t <- unlist(res[[i]]$`ot:source_node_ages`)
  
  if(is.null(t)) {
    
    
    ages[[i]]<-NA
    
    
  } else{
    a <- as.numeric(t[names(t) == "age"])
    
    ages[[i]] <- sort(a)
  }
}


## assigning numeric nodes rather than ottids for using chronos later on 

numericNodes<-function(phy) {
  
  n<-length(phy$tip.label)
  m<-phy$Nnode
  phy$node.label<-(n+1):(n+m)
  phy
}

synth_tree<-numericNodes(synth_tree)


## taking the minimum and maximum node ages per node
mins<-sapply(ages, FUN=min)

maxs<-sapply(ages, FUN=max)

## naming the mins and maxs by what node they are for to keep track when dropping NAs 
names(mins)<-synth_tree$node.label
names(maxs)<-synth_tree$node.label

mins<-na.omit(mins)
maxs<-na.omit(maxs)

#maxs <- maxs + 1

## making up branch lengths
synth_tree$edge.length <- rep(1, length(synth_tree$edge)/2)


## making dated tree, what model should we assume? 
ChronosCalib<-ape::makeChronosCalib(synth_tree, age.min = mins, age.max = maxs, node = as.numeric(names(mins)))

#cho <- chronos2(synth_tree, model = "relaxed", calibration =  ChronosCalib)

chronogramD <-ape::chronos(synth_tree, model="discrete", calibration=ChronosCalib)
chronogramC <- ape::chronos(synth_tree, model="correlated", calibration=ChronosCalib)
chronogramR <- ape::chronos(synth_tree, model = "relaxed", calibration =ChronosCalib)

par(mfrow = c(1,3))
plot(chronogramD, main = "discrete")
plot(chronogramC, main = "correlated")
plot(chronogramR, main = "relaxed")

## to make tree data, match ottids with tip names & test phylo.d have to change class to be phylo (it already one of the classes, it's just not first)
class(chronogramR)<-"phylo"

# getting the obs limited to the species data weve got

td <- make.treedata(chronogramR, o)
```

```{r}
head(o)
```

## testing for phylogenetic signal in native status 

```{r}
data<-as.data.frame(td$dat)
## using D-statistic (for discrete data) to test for phylogenetic signal
caper::phylo.d(data, td$phy, names.col = scientific_name, binvar = native)
```


# ploting phylo 

```{r}

library("jpeg")

imgs <- list()

for(i in 1:length(td$dat$image_url)){ 
  # catching broken urls 
  if(isTRUE(td$dat$image_url[i] == "")) {
    td$dat <- td$dat[-i,]
  }
  else {
    z <- tempfile()
    download.file(as.character(td$dat$image_url[i]),z,mode="wb")
    imgs[[i]] <- readJPEG(z)
    file.remove(z)
  }
  
}

```



```{r}

# making images plot 

pdf(file = "attempt.pdf")
plot(td$phy, x.lim =c(0, 200), show.tip.label=TRUE)
coords<-get("last_plot.phylo",envir=.PlotPhyloEnv)

xy <- data.frame(x=coords$xx[1:length(td$phy$tip.label)]*1.4, y=coords$yy[1:length(td$phy$tip.label)])


# doesnt work
for(i in 1:length(imgs)) {
  thumbnails(xy[,1], xy[,2], imgs[[i]], width= 1/length(td$phy$tip.label)*diff(coords$x.lim), height=diff(coords$y.lim)/length(td$phy$tip.label))
}

TL <- round(sum(td$phy$edge.length))

suffix <- ifelse(TL > 1000, " billion years of evolution today!", " million years of evolution today!")

TL <- ifelse(TL > 1000, TL/1000, TL)

text(0,diff(coords$y.lim)*0.05, paste0("You saw ", TL, suffix), pos=4, cex=1.5)

dev.off()
```



```{r}
phy$tip.label <- gsub(pattern = "_ott.*", replacement = "", x = phy$tip.label)

td <- make.treedata(phy,obs)
```



```{r}
imgs <- list()

for(i in 1:length(td$dat$image_url)){ 
  # catching broken urls 
  if(isTRUE(td$dat$image_url[i] == "")) {
    td$dat <- td$dat[-i,]
  }
  else {
  z <- tempfile()
  download.file(as.character(td$dat$image_url[i]),z,mode="wb")
  imgs[[i]] <- readJPEG(z)
  file.remove(z)
}

}

pdf(file = "attempt.pdf")
plot(td$phy, x.lim =c(0, 200), show.tip.label=TRUE)

coords<-get("last_plot.phylo",envir=.PlotPhyloEnv)

xy <- data.frame(x=coords$xx[1:length(td$phy$tip.label)]*1.4, y=coords$yy[1:length(td$phy$tip.label)])


# doesnt work
for(i in 1:length(imgs)) {
thumbnails(xy[,1], xy[,2], imgs, width= 1/length(td$phy$tip.label)*diff(coords$x.lim), height=diff(coords$y.lim)/length(td$phy$tip.label))
}
  
TL <- round(sum(td$phy$edge.length))

suffix <- ifelse(TL > 1000, " billion years of evolution today!", " million years of evolution today!")

TL <- ifelse(TL > 1000, TL/1000, TL)

text(0,diff(coords$y.lim)*0.05, paste0("You saw ", TL, suffix), pos=4, cex=1.5)

dev.off()
```


# TRASH

```{r}
sp <- que$cleaned_names

sp_ott <- getTaxonomyTable(sp, "class")


# make branch lengths = 1 

study <- rotl::studies_find_trees(property = "ot:ottTaxonName", "Magnoliopsida")


rand <- c(study$tree_ids[x], study$study_ids[x])

rand_tree <- get_study_tree(tree_id =  rand[1], study_id =  rand[2])

(rand_tree$tip.label %in% phy$tip.label)

# so far none of the tips have been included
tree_test <- keep.tip(rand_tree, tip = phy$tip.label)

```




